// sync允许在多个线程中转移所有权
// 只有实现了Send trait的类型才可以安全地在线程间转移所有权。
// 除了Rc<T>等极少数的类型，几乎所有的Rust类型都实现了Send trait：
// 如果你将克隆后的Rc<T>值的所有权转移到了另外一个线程中，
// 那么两个线程就有可能同时更新引用计数值并进而导致计数错误。
// 因此，Rc<T>只被设计在单线程场景中使用，它也无须为线程安全付出额外的性能开销。

// 任何完全由Send类型组成的复合类型都会被自动标记为Send。
// 除了我们在第19章将会讨论到的裸指针，几乎所有的原生类型都满足Send约束。

// Sync trait允许多线程同时访问
// 只有实现了Sync trait的类型才可以安全地被多个线程引用。
// 换句话说，对于任何类型T，如果&T（也就是T的引用）满足约束Send，那么T就是满足Sync的。
// 这意味着T的引用能够被安全地传递至另外的线程中。
// 与Send类似，所有原生类型都满足Sync约束，而完全由满足Sync的类型组成的复合类型也都会被自动识别为满足Sync的类型。
// 智能指针Rc<T>同样不满足Sync约束，其原因与它不满足Send约束类似。
// 在第15章讨论过的RefCell<T>类型及Cell<T>系列类型也不满足Sync约束。
// RefCell<T>实现的运行时借用检查并没有提供有关线程安全的保证。
// 而正如“在多个线程间共享Mutex<T>”一节中讨论的那样，智能指针Mutex<T>是Sync的，可以被多个线程共享访问。
fn main() {
    println!("Hello, world!");
}
