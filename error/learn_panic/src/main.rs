use std::vec;

fn main() {
    // 在Rust中，我们将错误分为两大类：可恢复错误与不可恢复错误。
    // 对于可恢复错误，比如文件未找到等，一般需要将它们报告给用户并再次尝试进行操作。
    // 而不可恢复错误往往就是bug的另一种说法，比如尝试访问超出数组结尾的位置等。


    // 提供了用于可恢复错误的类型Result<T, E>，以及在程序出现不可恢复错误时中止运行的panic! 宏。
    // panic!("crash and burn");


    // 当panic发生时，程序会默认开始栈展开。
    // 这意味着Rust会沿着调用栈的反向顺序遍历所有调用函数，并依次清理这些函数中的数据。


    // 除了展开，我们还可以选择立即终止程序，它会直接结束程序且不进行任何清理工作

    // 假如项目需要使最终二进制包尽可能小，那么你可以通过在Cargo.toml文件中的[profile]区域添加panic = 'abort'来将panic的默认行为从展开切换为终止。

    // 在其他某些情况下，panic! 调用可能会出现在我们所依赖的某些代码里，
    // 这段错误提示信息所指明的文件名和行号也会对应那些被依赖代码中发生panic! 调用的地方。
    // 我们依然可以通过查看panic! 调用函数的回溯信息来定位代码出现问题的地方。那么回溯信息又是什么呢？让我们接着来详细地了解一下。

    let v = vec![1,2,3];
    v[90];

    //使用范围
    // 对于某些不太常见的场景，直接触发panic要比返回Result更为合适一些。
    // 在定义一个可能失败的函数时优先考虑使用Result方案。

    // 当某个错误可能会导致代码处于损坏状态时，我们推荐你在代码中使用panic来处理错误。
    // 在这种情形下，损坏状态意味着设计中的一些假设、保证、约定或不可变性出现了被打破的情形。

    // 比如，当某些非法的值、自相矛盾的值或不存在的值被传入代码中，且满足下列某个条件时：
    // • 损坏状态并不包括预期中会偶尔发生的事情。
    // • 随后的代码无法在出现损坏状态后继续正常运行。
    // • 没有合适的方法来将“处于损坏状态”这一信息编码至我们所使用的类型中。

    // 假如用户在使用你的代码时传入了一些毫无意义的值，最好的办法也许就是调用panic! 来警告他们代码中出现了bug，
    // 以便用户提前在开发过程中发现并解决这些问题。
    // 类似地，当你调用某些不可控制的外部代码，且这些代码出现了无法修复的非法状态时，也可以直接调用panic!。

    // 当你的代码基于某些值来执行操作时，应该首先验证值的有效性，并在其无效时触发panic
    // 尝试基于某些非法值去进行操作可能会暴露代码中的漏洞。
    // 这也是标准库会在我们尝试进行越界访问时触发panic的主要原因：尝试访问不属于当前数据结构的内存是一个普遍的安全性问题。
}
